# Auto-generated with h2o

_go()
{
    local i=1 cmd cur word_list
    cur="${COMP_WORDS[COMP_CWORD]}"

    # take the last word that's NOT starting with -
    while [[ ( "$i" < "$COMP_CWORD" ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          -*) ;;
          *)
            cmd="$s"
            ;;
        esac
        (( i++ ))
    done

    case "$cmd" in
          bug) _go_bug
            return
            ;;

          build) _go_build
            return
            ;;

          clean) _go_clean
            return
            ;;

          doc) _go_doc
            return
            ;;

          env) _go_env
            return
            ;;

          fix) _go_fix
            return
            ;;

          fmt) _go_fmt
            return
            ;;

          generate) _go_generate
            return
            ;;

          get) _go_get
            return
            ;;

          install) _go_install
            return
            ;;

          list) _go_list
            return
            ;;

          mod) _go_mod
            return
            ;;

          work) _go_work
            return
            ;;

          run) _go_run
            return
            ;;

          test) _go_test
            return
            ;;

          tool) _go_tool
            return
            ;;

          version) _go_version
            return
            ;;

          vet) _go_vet
            return
            ;;

          buildconstraint) _go_buildconstraint
            return
            ;;

          buildmode) _go_buildmode
            return
            ;;

          c) _go_c
            return
            ;;

          cache) _go_cache
            return
            ;;

          environment) _go_environment
            return
            ;;

          filetype) _go_filetype
            return
            ;;

          gopath) _go_gopath
            return
            ;;

          gopath-get) _go_gopathget
            return
            ;;

          goproxy) _go_goproxy
            return
            ;;

          importpath) _go_importpath
            return
            ;;

          modules) _go_modules
            return
            ;;

          module-get) _go_moduleget
            return
            ;;

          module-auth) _go_moduleauth
            return
            ;;

          packages) _go_packages
            return
            ;;

          private) _go_private
            return
            ;;

          testflag) _go_testflag
            return
            ;;

          testfunc) _go_testfunc
            return
            ;;

          vcs) _go_vcs
            return
            ;;

      *)
          word_list=" bug build clean doc env fix fmt generate get install list mod work run test tool version vet buildconstraint buildmode c cache environment filetype gopath gopath-get goproxy importpath modules module-get module-auth packages private testflag testfunc vcs "
          COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
          ;;
    esac

}

_go_build ()
{
    local cur word_list
    word_list=" -a -n -p -race -msan -asan -v -work -x -asmflags -buildmode -buildvcs -compiler -gccgoflags -gcflags -installsuffix -ldflags -linkshared -mod -modcacherw -modfile -overlay -pkgdir -tags -trimpath -toolexec" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_go_doc ()
{
    local cur word_list
    local i=1 subcommand_index

    # take the last word that's NOT starting with -
    while [[ ( $i < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          doc)
            subcommand_index=$i
            break
            ;;
        esac
        (( i++ ))
    done

    while [[ ( $subcommand_index < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[subcommand_index}"
        case "$s" in
          documentation) _go_documentation
            return
            ;;

          *)  ;; 
        esac
        (( subcommand_index++ ))
    done

    word_list=" documentation -all -c -cmd -short -src -u" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_go_generate ()
{
    local cur word_list
    word_list=" -run" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_go_mod ()
{
    local cur word_list
    local i=1 subcommand_index

    # take the last word that's NOT starting with -
    while [[ ( $i < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          mod)
            subcommand_index=$i
            break
            ;;
        esac
        (( i++ ))
    done

    while [[ ( $subcommand_index < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[subcommand_index}"
        case "$s" in
          download) _go_download
            return
            ;;

          edit) _go_edit
            return
            ;;

          graph) _go_graph
            return
            ;;

          init) _go_init
            return
            ;;

          tidy) _go_tidy
            return
            ;;

          vendor) _go_vendor
            return
            ;;

          verify) _go_verify
            return
            ;;

          why) _go_why
            return
            ;;

          *)  ;; 
        esac
        (( subcommand_index++ ))
    done

    word_list=" download edit graph init tidy vendor verify why" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_go_work ()
{
    local cur word_list
    local i=1 subcommand_index

    # take the last word that's NOT starting with -
    while [[ ( $i < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          work)
            subcommand_index=$i
            break
            ;;
        esac
        (( i++ ))
    done

    while [[ ( $subcommand_index < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[subcommand_index}"
        case "$s" in
          edit) _go_edit
            return
            ;;

          init) _go_init
            return
            ;;

          sync) _go_sync
            return
            ;;

          use) _go_use
            return
            ;;

          *)  ;; 
        esac
        (( subcommand_index++ ))
    done

    word_list=" edit init sync use" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_go_test ()
{
    local cur word_list
    word_list=" -args -c -exec -i -json -o" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_go_buildconstraint ()
{
    local cur word_list
    word_list=" -" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_go_buildmode ()
{
    local cur word_list
    word_list=" -buildmode -buildmode -buildmode -buildmode -buildmode -buildmode -buildmode -buildmode" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_go_testflag ()
{
    local cur word_list
    word_list=" -bench -benchtime -count -cover -covermode -coverpkg -cpu -failfast -fuzz -fuzztime -fuzzminimizetime -json -list -parallel -run -short -shuffle -timeout -v -vet -benchmem -blockprofile -blockprofilerate -coverprofile -cpuprofile -memprofile -memprofilerate -mutexprofile -mutexprofilefraction -outputdir -trace" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

## -o bashdefault and -o default are fallback
complete -o bashdefault -o default -F _go go
