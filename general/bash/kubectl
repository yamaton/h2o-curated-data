# Auto-generated with h2o

_kubectl()
{
    local i=1 cmd cur word_list
    cur="${COMP_WORDS[COMP_CWORD]}"

    # take the last word that's NOT starting with -
    while [[ ( "$i" < "$COMP_CWORD" ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          -*) ;;
          *)
            cmd="$s"
            ;;
        esac
        (( i++ ))
    done

    case "$cmd" in
          create) _kubectl_create
            return
            ;;

          expose) _kubectl_expose
            return
            ;;

          run) _kubectl_run
            return
            ;;

          set) _kubectl_set
            return
            ;;

          explain) _kubectl_explain
            return
            ;;

          get) _kubectl_get
            return
            ;;

          edit) _kubectl_edit
            return
            ;;

          delete) _kubectl_delete
            return
            ;;

          rollout) _kubectl_rollout
            return
            ;;

          scale) _kubectl_scale
            return
            ;;

          autoscale) _kubectl_autoscale
            return
            ;;

          certificate) _kubectl_certificate
            return
            ;;

          cluster-info) _kubectl_clusterinfo
            return
            ;;

          top) _kubectl_top
            return
            ;;

          cordon) _kubectl_cordon
            return
            ;;

          uncordon) _kubectl_uncordon
            return
            ;;

          drain) _kubectl_drain
            return
            ;;

          taint) _kubectl_taint
            return
            ;;

          describe) _kubectl_describe
            return
            ;;

          logs) _kubectl_logs
            return
            ;;

          attach) _kubectl_attach
            return
            ;;

          exec) _kubectl_exec
            return
            ;;

          port-forward) _kubectl_portforward
            return
            ;;

          proxy) _kubectl_proxy
            return
            ;;

          cp) _kubectl_cp
            return
            ;;

          auth) _kubectl_auth
            return
            ;;

          debug) _kubectl_debug
            return
            ;;

          diff) _kubectl_diff
            return
            ;;

          apply) _kubectl_apply
            return
            ;;

          patch) _kubectl_patch
            return
            ;;

          replace) _kubectl_replace
            return
            ;;

          wait) _kubectl_wait
            return
            ;;

          kustomize) _kubectl_kustomize
            return
            ;;

          label) _kubectl_label
            return
            ;;

          annotate) _kubectl_annotate
            return
            ;;

          completion) _kubectl_completion
            return
            ;;

          alpha) _kubectl_alpha
            return
            ;;

          api-resources) _kubectl_apiresources
            return
            ;;

          api-versions) _kubectl_apiversions
            return
            ;;

          config) _kubectl_config
            return
            ;;

          plugin) _kubectl_plugin
            return
            ;;

          version) _kubectl_version
            return
            ;;

      *)
          word_list=" create expose run set explain get edit delete rollout scale autoscale certificate cluster-info top cordon uncordon drain taint describe logs attach exec port-forward proxy cp auth debug diff apply patch replace wait kustomize label annotate completion alpha api-resources api-versions config plugin version "
          COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
          ;;
    esac

}

_kubectl_create ()
{
    local cur word_list
    local i=1 subcommand_index

    # take the last word that's NOT starting with -
    while [[ ( $i < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          create)
            subcommand_index=$i
            break
            ;;
        esac
        (( i++ ))
    done

    while [[ ( $subcommand_index < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[subcommand_index}"
        case "$s" in
          clusterrole) _kubectl_clusterrole
            return
            ;;

          clusterrolebinding) _kubectl_clusterrolebinding
            return
            ;;

          configmap) _kubectl_configmap
            return
            ;;

          cronjob) _kubectl_cronjob
            return
            ;;

          deployment) _kubectl_deployment
            return
            ;;

          ingress) _kubectl_ingress
            return
            ;;

          job) _kubectl_job
            return
            ;;

          namespace) _kubectl_namespace
            return
            ;;

          poddisruptionbudget) _kubectl_poddisruptionbudget
            return
            ;;

          priorityclass) _kubectl_priorityclass
            return
            ;;

          quota) _kubectl_quota
            return
            ;;

          role) _kubectl_role
            return
            ;;

          rolebinding) _kubectl_rolebinding
            return
            ;;

          secret) _kubectl_secret
            return
            ;;

          service) _kubectl_service
            return
            ;;

          serviceaccount) _kubectl_serviceaccount
            return
            ;;

          *)  ;; 
        esac
        (( subcommand_index++ ))
    done

    word_list=" clusterrole clusterrolebinding configmap cronjob deployment ingress job namespace poddisruptionbudget priorityclass quota role rolebinding secret service serviceaccount --allow-missing-template-keys --dry-run --edit --field-manager -k --kustomize -o --output --raw -R --recursive --save-config -l --selector --show-managed-fields --template --validate --windows-line-endings" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_create_clusterrole ()
{
    local cur word_list
    word_list=" --aggregation-rule --allow-missing-template-keys --dry-run --field-manager -o --output --save-config --show-managed-fields --template --validate" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_create_clusterrolebinding ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --clusterrole --dry-run --field-manager -o --output --save-config --show-managed-fields --template --validate" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_create_configmap ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --append-hash --dry-run --field-manager -o --output --save-config --show-managed-fields --template --validate" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_create_cronjob ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --dry-run --field-manager --image -o --output --restart --save-config --schedule --show-managed-fields --template --validate" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_create_deployment ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --dry-run --field-manager -o --output --port -r --replicas --save-config --show-managed-fields --template --validate" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_create_ingress ()
{
    local cur word_list
    word_list=" --rule --allow-missing-template-keys --class --default-backend --dry-run --field-manager -o --output --save-config --show-managed-fields --template --validate" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_create_job ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --dry-run --field-manager --from --image -o --output --save-config --show-managed-fields --template --validate" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_create_namespace ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --dry-run --field-manager -o --output --save-config --show-managed-fields --template --validate" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_create_poddisruptionbudget ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --dry-run --field-manager --max-unavailable --min-available -o --output --save-config --selector --show-managed-fields --template --validate" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_create_priorityclass ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --description --dry-run --field-manager --global-default -o --output --preemption-policy --save-config --show-managed-fields --template --validate --value" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_create_quota ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --dry-run --field-manager --hard -o --output --save-config --scopes --show-managed-fields --template --validate" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_create_role ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --dry-run --field-manager -o --output --save-config --show-managed-fields --template --validate" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_create_rolebinding ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --clusterrole --dry-run --field-manager -o --output --role --save-config --show-managed-fields --template --validate" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_create_secret ()
{
    local cur word_list
    local i=1 subcommand_index

    # take the last word that's NOT starting with -
    while [[ ( $i < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          secret)
            subcommand_index=$i
            break
            ;;
        esac
        (( i++ ))
    done

    while [[ ( $subcommand_index < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[subcommand_index}"
        case "$s" in
          docker-registry) _create_dockerregistry
            return
            ;;

          generic) _create_generic
            return
            ;;

          tls) _create_tls
            return
            ;;

          *)  ;; 
        esac
        (( subcommand_index++ ))
    done

    word_list=" docker-registry generic tls" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_secret_dockerregistry ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --append-hash --docker-email --docker-password --docker-server --docker-username --dry-run --field-manager -o --output --save-config --show-managed-fields --template --validate" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_secret_generic ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --append-hash --dry-run --field-manager -o --output --save-config --show-managed-fields --template --type --validate" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_secret_tls ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --append-hash --cert --dry-run --field-manager --key -o --output --save-config --show-managed-fields --template --validate" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_create_service ()
{
    local cur word_list
    local i=1 subcommand_index

    # take the last word that's NOT starting with -
    while [[ ( $i < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          service)
            subcommand_index=$i
            break
            ;;
        esac
        (( i++ ))
    done

    while [[ ( $subcommand_index < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[subcommand_index}"
        case "$s" in
          clusterip) _create_clusterip
            return
            ;;

          externalname) _create_externalname
            return
            ;;

          loadbalancer) _create_loadbalancer
            return
            ;;

          nodeport) _create_nodeport
            return
            ;;

          *)  ;; 
        esac
        (( subcommand_index++ ))
    done

    word_list=" clusterip externalname loadbalancer nodeport" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_service_clusterip ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --clusterip --dry-run --field-manager -o --output --save-config --show-managed-fields --template --validate" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_service_externalname ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --dry-run --external-name --field-manager -o --output --save-config --show-managed-fields --template --validate" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_service_loadbalancer ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --dry-run --field-manager -o --output --save-config --show-managed-fields --template --validate" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_service_nodeport ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --dry-run --field-manager --node-port -o --output --save-config --show-managed-fields --template --validate" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_create_serviceaccount ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --dry-run --field-manager -o --output --save-config --show-managed-fields --template --validate" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_expose ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --cluster-ip --dry-run --external-ip --field-manager --generator -k --kustomize -l --labels --load-balancer-ip --name -o --output --override-type --overrides --port --protocol -R --recursive --save-config --selector --session-affinity --show-managed-fields --target-port --template --type" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_run ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --attach --cascade --command --dry-run --expose --field-manager --force --grace-period --image --image-pull-policy -k --kustomize -l --labels --leave-stdin-open -o --output --override-type --overrides --pod-running-timeout --port --privileged -q --quiet -R --recursive --restart --rm --save-config --show-managed-fields -i --stdin --template --timeout -t --tty --wait" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_set ()
{
    local cur word_list
    local i=1 subcommand_index

    # take the last word that's NOT starting with -
    while [[ ( $i < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          set)
            subcommand_index=$i
            break
            ;;
        esac
        (( i++ ))
    done

    while [[ ( $subcommand_index < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[subcommand_index}"
        case "$s" in
          env) _kubectl_env
            return
            ;;

          image) _kubectl_image
            return
            ;;

          resources) _kubectl_resources
            return
            ;;

          selector) _kubectl_selector
            return
            ;;

          serviceaccount) _kubectl_serviceaccount
            return
            ;;

          subject) _kubectl_subject
            return
            ;;

          *)  ;; 
        esac
        (( subcommand_index++ ))
    done

    word_list=" env image resources selector serviceaccount subject" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_set_env ()
{
    local cur word_list
    word_list=" --all --allow-missing-template-keys -c --containers --dry-run --field-manager --from -k --kustomize --list --local -o --output --overwrite --prefix -R --recursive --resolve -l --selector --show-managed-fields --template" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_set_image ()
{
    local cur word_list
    word_list=" --all --allow-missing-template-keys --dry-run --field-manager -k --kustomize --local -o --output -R --recursive -l --selector --show-managed-fields --template" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_set_resources ()
{
    local cur word_list
    word_list=" --all --allow-missing-template-keys -c --containers --dry-run --field-manager -k --kustomize --limits --local -o --output -R --recursive --requests -l --selector --show-managed-fields --template" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_set_selector ()
{
    local cur word_list
    word_list=" --all --allow-missing-template-keys --dry-run --field-manager --local -o --output -R --recursive --resource-version --show-managed-fields --template" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_set_serviceaccount ()
{
    local cur word_list
    word_list=" --all --allow-missing-template-keys --dry-run --field-manager -k --kustomize --local -o --output -R --recursive --show-managed-fields --template" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_set_subject ()
{
    local cur word_list
    word_list=" --all --allow-missing-template-keys --dry-run --field-manager -k --kustomize --local -o --output -R --recursive -l --selector --show-managed-fields --template" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_explain ()
{
    local cur word_list
    word_list=" --api-version --recursive" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_get ()
{
    local cur word_list
    word_list=" -A --all-namespaces --allow-missing-template-keys --chunk-size --field-selector --ignore-not-found -k --kustomize --no-headers -o --output --output-watch-events --raw -R --recursive -l --selector --server-print --show-kind --show-labels --show-managed-fields --sort-by --template -w --watch --watch-only" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_edit ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --field-manager -k --kustomize -o --output --output-patch -R --recursive --save-config --show-managed-fields --template --validate --windows-line-endings" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_delete ()
{
    local cur word_list
    word_list=" --all -A --all-namespaces --cascade --dry-run --field-selector --force --grace-period --ignore-not-found -k --kustomize --now -o --output --raw -R --recursive -l --selector --timeout --wait" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_rollout ()
{
    local cur word_list
    local i=1 subcommand_index

    # take the last word that's NOT starting with -
    while [[ ( $i < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          rollout)
            subcommand_index=$i
            break
            ;;
        esac
        (( i++ ))
    done

    while [[ ( $subcommand_index < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[subcommand_index}"
        case "$s" in
          history) _kubectl_history
            return
            ;;

          pause) _kubectl_pause
            return
            ;;

          restart) _kubectl_restart
            return
            ;;

          resume) _kubectl_resume
            return
            ;;

          status) _kubectl_status
            return
            ;;

          undo) _kubectl_undo
            return
            ;;

          *)  ;; 
        esac
        (( subcommand_index++ ))
    done

    word_list=" history pause restart resume status undo" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_rollout_history ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys -k --kustomize -o --output -R --recursive --revision --show-managed-fields --template" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_rollout_pause ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --field-manager -k --kustomize -o --output -R --recursive --show-managed-fields --template" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_rollout_restart ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --field-manager -k --kustomize -o --output -R --recursive --show-managed-fields --template" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_rollout_resume ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --field-manager -k --kustomize -o --output -R --recursive --show-managed-fields --template" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_rollout_status ()
{
    local cur word_list
    word_list=" -k --kustomize -R --recursive --revision --timeout -w --watch" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_rollout_undo ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --dry-run -k --kustomize -o --output -R --recursive --show-managed-fields --template --to-revision" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_scale ()
{
    local cur word_list
    word_list=" --all --allow-missing-template-keys --current-replicas --dry-run -k --kustomize -o --output -R --recursive --replicas --resource-version -l --selector --show-managed-fields --template --timeout" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_autoscale ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --cpu-percent --dry-run --field-manager -k --kustomize --max --min --name -o --output -R --recursive --save-config --show-managed-fields --template" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_certificate ()
{
    local cur word_list
    local i=1 subcommand_index

    # take the last word that's NOT starting with -
    while [[ ( $i < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          certificate)
            subcommand_index=$i
            break
            ;;
        esac
        (( i++ ))
    done

    while [[ ( $subcommand_index < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[subcommand_index}"
        case "$s" in
          approve) _kubectl_approve
            return
            ;;

          deny) _kubectl_deny
            return
            ;;

          *)  ;; 
        esac
        (( subcommand_index++ ))
    done

    word_list=" approve deny" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_certificate_approve ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --force -k --kustomize -o --output -R --recursive --show-managed-fields --template" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_certificate_deny ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --force -k --kustomize -o --output -R --recursive --show-managed-fields --template" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_top ()
{
    local cur word_list
    local i=1 subcommand_index

    # take the last word that's NOT starting with -
    while [[ ( $i < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          top)
            subcommand_index=$i
            break
            ;;
        esac
        (( i++ ))
    done

    while [[ ( $subcommand_index < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[subcommand_index}"
        case "$s" in
          node) _kubectl_node
            return
            ;;

          pod) _kubectl_pod
            return
            ;;

          *)  ;; 
        esac
        (( subcommand_index++ ))
    done

    word_list=" node pod" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_top_node ()
{
    local cur word_list
    word_list=" --no-headers -l --selector --show-capacity --sort-by --use-protocol-buffers" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_top_pod ()
{
    local cur word_list
    word_list=" -A --all-namespaces --containers --field-selector --no-headers -l --selector --sort-by --use-protocol-buffers" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_cordon ()
{
    local cur word_list
    word_list=" --dry-run -l --selector" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_uncordon ()
{
    local cur word_list
    word_list=" --dry-run -l --selector" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_drain ()
{
    local cur word_list
    word_list=" --chunk-size --delete-emptydir-data --disable-eviction --dry-run --force --grace-period --ignore-daemonsets --pod-selector -l --selector --skip-wait-for-delete-timeout --timeout" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_taint ()
{
    local cur word_list
    word_list=" --all --allow-missing-template-keys --dry-run --field-manager -o --output --overwrite -l --selector --show-managed-fields --template --validate" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_describe ()
{
    local cur word_list
    word_list=" -A --all-namespaces --chunk-size -k --kustomize -R --recursive -l --selector --show-events" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_logs ()
{
    local cur word_list
    word_list=" --all-containers -c --container -f --follow --ignore-errors --insecure-skip-tls-verify-backend --limit-bytes --max-log-requests --pod-running-timeout --prefix -p --previous -l --selector --since --since-time --tail --timestamps" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_attach ()
{
    local cur word_list
    word_list=" -c --container --pod-running-timeout -q --quiet -i --stdin -t --tty" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_exec ()
{
    local cur word_list
    word_list=" -c --container --pod-running-timeout -q --quiet -i --stdin -t --tty" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_portforward ()
{
    local cur word_list
    word_list=" --address --address --pod-running-timeout" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_proxy ()
{
    local cur word_list
    word_list=" --accept-hosts --accept-hosts --accept-paths --address --api-prefix --append-server-path --disable-filter --keepalive -p --port --reject-methods --reject-paths -u --unix-socket -w --www -P --www-prefix" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_cp ()
{
    local cur word_list
    word_list=" -c --container --no-preserve --retries" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_auth ()
{
    local cur word_list
    local i=1 subcommand_index

    # take the last word that's NOT starting with -
    while [[ ( $i < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          auth)
            subcommand_index=$i
            break
            ;;
        esac
        (( i++ ))
    done

    while [[ ( $subcommand_index < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[subcommand_index}"
        case "$s" in
          can-i) _kubectl_cani
            return
            ;;

          reconcile) _kubectl_reconcile
            return
            ;;

          *)  ;; 
        esac
        (( subcommand_index++ ))
    done

    word_list=" can-i reconcile" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_auth_cani ()
{
    local cur word_list
    word_list=" -A --all-namespaces --list --no-headers -q --quiet --subresource" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_auth_reconcile ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --dry-run -k --kustomize -o --output -R --recursive --remove-extra-permissions --remove-extra-subjects --show-managed-fields --template" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_debug ()
{
    local cur word_list
    word_list=" --arguments-only --attach -c --container --copy-to --image --image-pull-policy -q --quiet --replace --same-node --share-processes -i --stdin --target -t --tty" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_diff ()
{
    local cur word_list
    word_list=" --field-manager --force-conflicts -k --kustomize -R --recursive -l --selector --server-side" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_apply ()
{
    local cur word_list
    word_list=" --all --allow-missing-template-keys --cascade --dry-run --field-manager --force --force-conflicts --grace-period -k --kustomize --openapi-patch -o --output --overwrite --prune -R --recursive -l --selector --server-side --show-managed-fields --template --timeout --validate --wait" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_patch ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --dry-run --field-manager -k --kustomize --local -o --output -p --patch --patch-file -R --recursive --show-managed-fields --template --type" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_replace ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --cascade --dry-run --field-manager --force --grace-period -k --kustomize -o --output --raw -R --recursive --save-config --show-managed-fields --template --timeout --validate --wait" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_wait ()
{
    local cur word_list
    word_list=" --all -A --all-namespaces --allow-missing-template-keys --field-selector --for --local -o --output -R --recursive -l --selector --show-managed-fields --template --timeout" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_kustomize ()
{
    local cur word_list
    word_list=" --as-current-user --enable-alpha-plugins --enable-helm --enable-managedby-label --helm-command --load-restrictor --network --network-name -o --output --reorder" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_label ()
{
    local cur word_list
    word_list=" --all -A --all-namespaces --allow-missing-template-keys --dry-run --field-manager --field-selector -k --kustomize --list --local -o --output --overwrite -R --recursive --resource-version -l --selector --show-managed-fields --template" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_annotate ()
{
    local cur word_list
    word_list=" --all -A --all-namespaces --allow-missing-template-keys --dry-run --field-manager --field-selector -k --kustomize --list --local -o --output --overwrite -R --recursive --resource-version -l --selector --show-managed-fields --template" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_alpha ()
{
    local cur word_list
    local i=1 subcommand_index

    # take the last word that's NOT starting with -
    while [[ ( $i < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          alpha)
            subcommand_index=$i
            break
            ;;
        esac
        (( i++ ))
    done

    while [[ ( $subcommand_index < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[subcommand_index}"
        case "$s" in
          events) _kubectl_events
            return
            ;;

          *)  ;; 
        esac
        (( subcommand_index++ ))
    done

    word_list=" events" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_alpha_events ()
{
    local cur word_list
    word_list=" -A --all-namespaces --chunk-size --for -w --watch" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_apiresources ()
{
    local cur word_list
    word_list=" --api-group --cached --namespaced --no-headers -o --output --sort-by" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_config ()
{
    local cur word_list
    local i=1 subcommand_index

    # take the last word that's NOT starting with -
    while [[ ( $i < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          config)
            subcommand_index=$i
            break
            ;;
        esac
        (( i++ ))
    done

    while [[ ( $subcommand_index < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[subcommand_index}"
        case "$s" in
          current-context) _kubectl_currentcontext
            return
            ;;

          delete-cluster) _kubectl_deletecluster
            return
            ;;

          delete-context) _kubectl_deletecontext
            return
            ;;

          delete-user) _kubectl_deleteuser
            return
            ;;

          get-clusters) _kubectl_getclusters
            return
            ;;

          get-contexts) _kubectl_getcontexts
            return
            ;;

          get-users) _kubectl_getusers
            return
            ;;

          rename-context) _kubectl_renamecontext
            return
            ;;

          set) _kubectl_set
            return
            ;;

          set-cluster) _kubectl_setcluster
            return
            ;;

          set-context) _kubectl_setcontext
            return
            ;;

          set-credentials) _kubectl_setcredentials
            return
            ;;

          unset) _kubectl_unset
            return
            ;;

          use-context) _kubectl_usecontext
            return
            ;;

          view) _kubectl_view
            return
            ;;

          *)  ;; 
        esac
        (( subcommand_index++ ))
    done

    word_list=" current-context delete-cluster delete-context delete-user get-clusters get-contexts get-users rename-context set set-cluster set-context set-credentials unset use-context view" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_config_getcontexts ()
{
    local cur word_list
    word_list=" --no-headers -o --output" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_config_set ()
{
    local cur word_list
    word_list=" --set-raw-bytes" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_config_setcluster ()
{
    local cur word_list
    word_list=" --embed-certs" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_config_setcontext ()
{
    local cur word_list
    word_list=" --current" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_config_setcredentials ()
{
    local cur word_list
    word_list=" --client-certificate --client-key --token --username --password --auth-provider --embed-certs --exec-api-version --exec-command" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_config_view ()
{
    local cur word_list
    word_list=" --allow-missing-template-keys --flatten --merge --minify -o --output --raw --show-managed-fields --template" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_plugin ()
{
    local cur word_list
    local i=1 subcommand_index

    # take the last word that's NOT starting with -
    while [[ ( $i < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          plugin)
            subcommand_index=$i
            break
            ;;
        esac
        (( i++ ))
    done

    while [[ ( $subcommand_index < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[subcommand_index}"
        case "$s" in
          list) _kubectl_list
            return
            ;;

          *)  ;; 
        esac
        (( subcommand_index++ ))
    done

    word_list=" list" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_plugin_list ()
{
    local cur word_list
    word_list=" --name-only" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_kubectl_version ()
{
    local cur word_list
    word_list=" --client -o --output --short" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

## -o bashdefault and -o default are fallback
complete -o bashdefault -o default -F _kubectl kubectl
