# Auto-generated with h2o

_minikube()
{
    local i=1 cmd cur word_list
    cur="${COMP_WORDS[COMP_CWORD]}"

    # take the last word that's NOT starting with -
    while [[ ( "$i" < "$COMP_CWORD" ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          -*) ;;
          *)
            cmd="$s"
            ;;
        esac
        (( i++ ))
    done

    case "$cmd" in
          start) _minikube_start
            return
            ;;

          status) _minikube_status
            return
            ;;

          stop) _minikube_stop
            return
            ;;

          delete) _minikube_delete
            return
            ;;

          dashboard) _minikube_dashboard
            return
            ;;

          pause) _minikube_pause
            return
            ;;

          unpause) _minikube_unpause
            return
            ;;

          docker-env) _minikube_dockerenv
            return
            ;;

          podman-env) _minikube_podmanenv
            return
            ;;

          cache) _minikube_cache
            return
            ;;

          image) _minikube_image
            return
            ;;

          addons) _minikube_addons
            return
            ;;

          config) _minikube_config
            return
            ;;

          profile) _minikube_profile
            return
            ;;

          update-context) _minikube_updatecontext
            return
            ;;

          service) _minikube_service
            return
            ;;

          tunnel) _minikube_tunnel
            return
            ;;

          mount) _minikube_mount
            return
            ;;

          ssh) _minikube_ssh
            return
            ;;

          kubectl) _minikube_kubectl
            return
            ;;

          node) _minikube_node
            return
            ;;

          cp) _minikube_cp
            return
            ;;

          ssh-key) _minikube_sshkey
            return
            ;;

          ssh-host) _minikube_sshhost
            return
            ;;

          ip) _minikube_ip
            return
            ;;

          logs) _minikube_logs
            return
            ;;

          update-check) _minikube_updatecheck
            return
            ;;

          version) _minikube_version
            return
            ;;

          options) _minikube_options
            return
            ;;

          completion) _minikube_completion
            return
            ;;

      *)
          word_list=" start status stop delete dashboard pause unpause docker-env podman-env cache image addons config profile update-context service tunnel mount ssh kubectl node cp ssh-key ssh-host ip logs update-check version options completion "
          COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
          ;;
    esac

}

_minikube_start ()
{
    local cur word_list
    word_list=" --container-runtime --extra-disks --feature-gates --force --force-systemd --host-dns-resolver --host-only-cidr --host-only-nic-type --hyperkit-vpnkit-sock --hyperv-external-adapter --hyperv-use-external-switch --hyperv-virtual-switch --image-mirror-country --image-repository --install-addons --interactive --iso-url --iso-url --keep-context --kubernetes-version --kvm-gpu --kvm-hidden --kvm-network --kvm-numa-count --kvm-qemu-uri --listen-address --memory --mount --mount-9p-version --mount-gid --mount-ip --mount-msize --mount-port --mount-string --mount-type --mount-uid --namespace --nat-nic-type --native-ssh --network --network-plugin --nfs-shares-root --no-kubernetes --no-vtx-check -n --nodes -o --output --preload --service-cluster-ip-range --ssh-ip-address --ssh-key --ssh-port --ssh-user --trace --uuid --vm --vm-driver --wait --wait-timeout" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_status ()
{
    local cur word_list
    word_list=" -l --layout -n --node -o --output -w --watch" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_stop ()
{
    local cur word_list
    word_list=" --all --cancel-scheduled --keep-context-active -o --output --schedule" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_delete ()
{
    local cur word_list
    word_list=" --all --purge" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_dashboard ()
{
    local cur word_list
    word_list=" --port --url" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_pause ()
{
    local cur word_list
    word_list=" -A --all-namespaces -n --namespaces -n --namespaces -o --output" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_unpause ()
{
    local cur word_list
    word_list=" -A --all-namespaces -n --namespaces -n --namespaces -o --output" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_dockerenv ()
{
    local cur word_list
    word_list=" --no-proxy -o --output --shell --ssh-add --ssh-host -u --unset" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_podmanenv ()
{
    local cur word_list
    word_list=" --shell -u --unset" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_cache ()
{
    local cur word_list
    local i=1 subcommand_index

    # take the last word that's NOT starting with -
    while [[ ( $i < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          cache)
            subcommand_index=$i
            break
            ;;
        esac
        (( i++ ))
    done

    while [[ ( $subcommand_index < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[subcommand_index}"
        case "$s" in
          add) _minikube_add
            return
            ;;

          delete) _minikube_delete
            return
            ;;

          list) _minikube_list
            return
            ;;

          reload) _minikube_reload
            return
            ;;

          *)  ;; 
        esac
        (( subcommand_index++ ))
    done

    word_list=" add delete list reload" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_cache_add ()
{
    local cur word_list
    word_list=" --all" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_image ()
{
    local cur word_list
    local i=1 subcommand_index

    # take the last word that's NOT starting with -
    while [[ ( $i < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          image)
            subcommand_index=$i
            break
            ;;
        esac
        (( i++ ))
    done

    while [[ ( $subcommand_index < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[subcommand_index}"
        case "$s" in
          build) _minikube_build
            return
            ;;

          load) _minikube_load
            return
            ;;

          ls) _minikube_ls
            return
            ;;

          pull) _minikube_pull
            return
            ;;

          push) _minikube_push
            return
            ;;

          rm) _minikube_rm
            return
            ;;

          save) _minikube_save
            return
            ;;

          tag) _minikube_tag
            return
            ;;

          *)  ;; 
        esac
        (( subcommand_index++ ))
    done

    word_list=" build load ls pull push rm save tag" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_image_build ()
{
    local cur word_list
    word_list=" --all -f --file -n --node --push -t --tag" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_image_load ()
{
    local cur word_list
    word_list=" --daemon --overwrite --pull --remote" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_image_ls ()
{
    local cur word_list
    word_list=" --format" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_image_save ()
{
    local cur word_list
    word_list=" --daemon --remote" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_addons ()
{
    local cur word_list
    local i=1 subcommand_index

    # take the last word that's NOT starting with -
    while [[ ( $i < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          addons)
            subcommand_index=$i
            break
            ;;
        esac
        (( i++ ))
    done

    while [[ ( $subcommand_index < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[subcommand_index}"
        case "$s" in
          configure) _minikube_configure
            return
            ;;

          disable) _minikube_disable
            return
            ;;

          enable) _minikube_enable
            return
            ;;

          images) _minikube_images
            return
            ;;

          list) _minikube_list
            return
            ;;

          open) _minikube_open
            return
            ;;

          *)  ;; 
        esac
        (( subcommand_index++ ))
    done

    word_list=" configure disable enable images list open" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_addons_enable ()
{
    local cur word_list
    word_list=" --force --images --refresh --registries" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_addons_list ()
{
    local cur word_list
    word_list=" -o --output" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_addons_open ()
{
    local cur word_list
    word_list=" --https --interval --url --wait" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_config ()
{
    local cur word_list
    local i=1 subcommand_index

    # take the last word that's NOT starting with -
    while [[ ( $i < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          config)
            subcommand_index=$i
            break
            ;;
        esac
        (( i++ ))
    done

    while [[ ( $subcommand_index < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[subcommand_index}"
        case "$s" in
          defaults) _minikube_defaults
            return
            ;;

          get) _minikube_get
            return
            ;;

          set) _minikube_set
            return
            ;;

          unset) _minikube_unset
            return
            ;;

          view) _minikube_view
            return
            ;;

          *)  ;; 
        esac
        (( subcommand_index++ ))
    done

    word_list=" defaults get set unset view" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_config_defaults ()
{
    local cur word_list
    word_list=" --output" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_config_view ()
{
    local cur word_list
    word_list=" --format" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_profile ()
{
    local cur word_list
    local i=1 subcommand_index

    # take the last word that's NOT starting with -
    while [[ ( $i < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          profile)
            subcommand_index=$i
            break
            ;;
        esac
        (( i++ ))
    done

    while [[ ( $subcommand_index < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[subcommand_index}"
        case "$s" in
          list) _minikube_list
            return
            ;;

          *)  ;; 
        esac
        (( subcommand_index++ ))
    done

    word_list=" list" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_profile_list ()
{
    local cur word_list
    word_list=" -l --light -o --output" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_service ()
{
    local cur word_list
    local i=1 subcommand_index

    # take the last word that's NOT starting with -
    while [[ ( $i < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          service)
            subcommand_index=$i
            break
            ;;
        esac
        (( i++ ))
    done

    while [[ ( $subcommand_index < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[subcommand_index}"
        case "$s" in
          list) _minikube_list
            return
            ;;

          *)  ;; 
        esac
        (( subcommand_index++ ))
    done

    word_list=" list --all --https --interval -n --namespace --url --wait" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_service_list ()
{
    local cur word_list
    word_list=" -n --namespace" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_tunnel ()
{
    local cur word_list
    word_list=" -c --cleanup" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_mount ()
{
    local cur word_list
    word_list=" --9p-version --gid --ip --kill --msize --port --type --uid" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_ssh ()
{
    local cur word_list
    word_list=" --native-ssh -n --node" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_kubectl ()
{
    local cur word_list
    word_list=" --ssh" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_node ()
{
    local cur word_list
    local i=1 subcommand_index

    # take the last word that's NOT starting with -
    while [[ ( $i < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          node)
            subcommand_index=$i
            break
            ;;
        esac
        (( i++ ))
    done

    while [[ ( $subcommand_index < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[subcommand_index}"
        case "$s" in
          add) _minikube_add
            return
            ;;

          delete) _minikube_delete
            return
            ;;

          list) _minikube_list
            return
            ;;

          start) _minikube_start
            return
            ;;

          stop) _minikube_stop
            return
            ;;

          *)  ;; 
        esac
        (( subcommand_index++ ))
    done

    word_list=" add delete list start stop" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_node_add ()
{
    local cur word_list
    word_list=" --control-plane --delete-on-failure --worker" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_node_start ()
{
    local cur word_list
    word_list=" --delete-on-failure" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_sshkey ()
{
    local cur word_list
    word_list=" -n --node" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_sshhost ()
{
    local cur word_list
    word_list=" --append-known -n --node" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_ip ()
{
    local cur word_list
    word_list=" -n --node" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_logs ()
{
    local cur word_list
    word_list=" --file -f --follow -n --length --node --problems" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_version ()
{
    local cur word_list
    word_list=" --components -o --output --short" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

_minikube_completion ()
{
    local cur word_list
    local i=1 subcommand_index

    # take the last word that's NOT starting with -
    while [[ ( $i < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[i]}"
        case "$s" in
          completion)
            subcommand_index=$i
            break
            ;;
        esac
        (( i++ ))
    done

    while [[ ( $subcommand_index < $COMP_CWORD ) ]]; do
        local s="${COMP_WORDS[subcommand_index}"
        case "$s" in
          bash) _minikube_bash
            return
            ;;

          fish) _minikube_fish
            return
            ;;

          zsh) _minikube_zsh
            return
            ;;

          *)  ;; 
        esac
        (( subcommand_index++ ))
    done

    word_list=" bash fish zsh" 
    cur="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=( $(compgen -W "${word_list}" -- "${cur}") )
}

## -o bashdefault and -o default are fallback
complete -o bashdefault -o default -F _minikube minikube
