{"name":"xsv","description":"xsv","usage":"xsv <command> [<args>...]\nxsv [options]","options":[{"names":["--list"],"argument":"","description":"List all commands available."},{"names":["-h","--help"],"argument":"","description":"Display this message"},{"names":["--version"],"argument":"","description":"Print version info and exit"}],"subcommands":[{"name":"cat","description":"Concatenate by row or column","usage":"xsv cat rows    [options] [<input>...]\nxsv cat columns [options] [<input>...]\nxsv cat --help","options":[{"names":["-p","--pad"],"argument":"","description":"When concatenating columns, this flag will cause all records to appear. It will pad each row if other CSV data isn't long enough."},{"names":["-h","--help"],"argument":"","description":"Display this message"},{"names":["-o","--output"],"argument":"<file>","description":"Write output to <file> instead of stdout."},{"names":["-n","--no-headers"],"argument":"","description":"When set, the first row will NOT be interpreted as column names. Note that this has no effect when concatenating columns."},{"names":["-d","--delimiter"],"argument":"<arg>","description":"The field delimiter for reading CSV data. Must be a single character. (default: ,)"}]},{"name":"count","description":"Count records","usage":"xsv count [options] [<input>]","options":[{"names":["-h","--help"],"argument":"","description":"Display this message"},{"names":["-n","--no-headers"],"argument":"","description":"When set, the first row will not be included in the count."},{"names":["-d","--delimiter"],"argument":"<arg>","description":"The field delimiter for reading CSV data. Must be a single character. (default: ,)"}]},{"name":"fixlengths","description":"Makes all records have same length","usage":"xsv fixlengths [options] [<input>]","options":[{"names":["-l","--length"],"argument":"<arg>","description":"Forcefully set the length of each record. If a record is not the size given, then it is truncated or expanded as appropriate."},{"names":["-h","--help"],"argument":"","description":"Display this message"},{"names":["-o","--output"],"argument":"<file>","description":"Write output to <file> instead of stdout."},{"names":["-d","--delimiter"],"argument":"<arg>","description":"The field delimiter for reading CSV data. Must be a single character. (default: ,)"}]},{"name":"flatten","description":"Show one field per line","usage":"xsv flatten [options] [<input>]","options":[{"names":["-c","--condense"],"argument":"<arg>","description":"Limits the length of each field to the value   specified. If the field is UTF-8 encoded, then <arg> refers to the number of code points. Otherwise, it refers to the number of bytes."},{"names":["-s","--separator"],"argument":"<arg>","description":"A string of characters to write after each record. When non-empty, a new line is automatically appended to the separator. [default: #]"},{"names":["-h","--help"],"argument":"","description":"Display this message"},{"names":["-n","--no-headers"],"argument":"","description":"When set, the first row will not be interpreted as headers. When set, the name of each field will be its index."},{"names":["-d","--delimiter"],"argument":"<arg>","description":"The field delimiter for reading CSV data. Must be a single character. (default: ,)"}]},{"name":"fmt","description":"Format CSV output (change field delimiter)","usage":"xsv fmt [options] [<input>]","options":[{"names":["-t","--out-delimiter"],"argument":"<arg>","description":"The field delimiter for writing CSV data. [default: ,]"},{"names":["--crlf"],"argument":"","description":"Use '\\r\\n' line endings in the output."},{"names":["--ascii"],"argument":"","description":"Use ASCII field and record separators."},{"names":["--quote"],"argument":"<arg>","description":"The quote character to use. [default: \"]"},{"names":["--quote-always"],"argument":"","description":"Put quotes around every value."},{"names":["--escape"],"argument":"<arg>","description":"The escape character to use. When not specified, quotes are escaped by doubling them."},{"names":["-h","--help"],"argument":"","description":"Display this message"},{"names":["-o","--output"],"argument":"<file>","description":"Write output to <file> instead of stdout."},{"names":["-d","--delimiter"],"argument":"<arg>","description":"The field delimiter for reading CSV data. Must be a single character. (default: ,)"}]},{"name":"frequency","description":"Show frequency tables","usage":"xsv frequency [options] [<input>]","options":[{"names":["-s","--select"],"argument":"<arg>","description":"Select a subset of columns to compute frequencies for. See 'xsv select --help' for the format details. This is provided here because piping 'xsv select' into 'xsv frequency' will disable the use of indexing."},{"names":["-l","--limit"],"argument":"<arg>","description":"Limit the frequency table to the N most common items. Set to '0' to disable a limit. [default: 10]"},{"names":["-a","--asc"],"argument":"","description":"Sort the frequency tables in ascending order by count. The default is descending order."},{"names":["--no-nulls"],"argument":"","description":"Don't include NULLs in the frequency table."},{"names":["-j","--jobs"],"argument":"<arg>","description":"The number of jobs to run in parallel. This works better when the given CSV data has an index already created. Note that a file handle is opened for each job. When set to '0', the number of jobs is set to the number of CPUs detected. [default: 0]"},{"names":["-h","--help"],"argument":"","description":"Display this message"},{"names":["-o","--output"],"argument":"<file>","description":"Write output to <file> instead of stdout."},{"names":["-n","--no-headers"],"argument":"","description":"When set, the first row will NOT be included in the frequency table. Additionally, the 'field' column will be 1-based indices instead of header names."},{"names":["-d","--delimiter"],"argument":"<arg>","description":"The field delimiter for reading CSV data. Must be a single character. (default: ,)"}]},{"name":"headers","description":"Show header names","usage":"xsv headers [options] [<input>...]","options":[{"names":["-j","--just-names"],"argument":"","description":"Only show the header names (hide column index). This is automatically enabled if more than one input is given."},{"names":["--intersect"],"argument":"","description":"Shows the intersection of all headers in all of the inputs given."},{"names":["-h","--help"],"argument":"","description":"Display this message"},{"names":["-d","--delimiter"],"argument":"<arg>","description":"The field delimiter for reading CSV data. Must be a single character. (default: ,)"}]},{"name":"help","description":"Show this usage message.","options":[{"names":["--list"],"argument":"","description":"List all commands available."},{"names":["-h","--help"],"argument":"","description":"Display this message"},{"names":["--version"],"argument":"","description":"Print version info and exit"}]},{"name":"index","description":"Create CSV index for faster access","usage":"xsv index [options] <input>\nxsv index --help","options":[{"names":["-o","--output"],"argument":"<file>","description":"Write index to <file> instead of <input>.idx. Generally, this is not currently useful because the only way to use an index is if it is specially named <input>.idx."},{"names":["-h","--help"],"argument":"","description":"Display this message"},{"names":["-d","--delimiter"],"argument":"<arg>","description":"The field delimiter for reading CSV data. Must be a single character. (default: ,)"}]},{"name":"input","description":"Read CSV data with special quoting rules","usage":"xsv input [options] [<input>]","options":[{"names":["--quote"],"argument":"<arg>","description":"The quote character to use. [default: \"]"},{"names":["--escape"],"argument":"<arg>","description":"The escape character to use. When not specified, quotes are escaped by doubling them."},{"names":["--no-quoting"],"argument":"","description":"Disable quoting completely."},{"names":["-h","--help"],"argument":"","description":"Display this message"},{"names":["-o","--output"],"argument":"<file>","description":"Write output to <file> instead of stdout."},{"names":["-d","--delimiter"],"argument":"<arg>","description":"The field delimiter for reading CSV data. Must be a single character. (default: ,)"}]},{"name":"join","description":"Join CSV files","usage":"xsv join [options] <columns1> <input1> <columns2> <input2>\nxsv join --help","options":[{"names":["--no-case"],"argument":"","description":"When set, joins are done case insensitively."},{"names":["--left"],"argument":"","description":"Do a 'left outer' join. This returns all rows in first CSV data set, including rows with no corresponding row in the second data set. When no corresponding row exists, it is padded out with empty fields."},{"names":["--right"],"argument":"","description":"Do a 'right outer' join. This returns all rows in second CSV data set, including rows with no corresponding row in the first data set. When no corresponding row exists, it is padded out with empty fields. (This is the reverse of 'outer left'.)"},{"names":["--full"],"argument":"","description":"Do a 'full outer' join. This returns all rows in both data sets with matching records joined. If there is no match, the missing side will be padded out with empty fields. (This is the combination of 'outer left' and 'outer right'.)"},{"names":["--cross"],"argument":"USE WITH CAUTION.","description":"This returns the cartesian product of the CSV data sets given. The number of rows return is equal to N * M, where N and M correspond to the number of rows in the given data sets, respectively."},{"names":["--nulls"],"argument":"","description":"When set, joins will work on empty fields. Otherwise, empty fields are completely ignored. (In fact, any row that has an empty field in the key specified is ignored.)"},{"names":["-h","--help"],"argument":"","description":"Display this message"},{"names":["-o","--output"],"argument":"<file>","description":"Write output to <file> instead of stdout."},{"names":["-n","--no-headers"],"argument":"","description":"When set, the first row will not be interpreted as headers. (i.e., They are not searched, analyzed, sliced, etc.)"},{"names":["-d","--delimiter"],"argument":"<arg>","description":"The field delimiter for reading CSV data. Must be a single character. (default: ,)"}]},{"name":"sample","description":"Randomly sample CSV data","usage":"xsv sample [options] <sample-size> [<input>]\nxsv sample --help","options":[{"names":["-h","--help"],"argument":"","description":"Display this message"},{"names":["-o","--output"],"argument":"<file>","description":"Write output to <file> instead of stdout."},{"names":["-n","--no-headers"],"argument":"","description":"When set, the first row will be consider as part of the population to sample from. (When not set, the first row is the header row and will always appear in the output.)"},{"names":["-d","--delimiter"],"argument":"<arg>","description":"The field delimiter for reading CSV data. Must be a single character. (default: ,)"}]},{"name":"search","description":"Search CSV data with regexes","usage":"xsv search [options] <regex> [<input>]\nxsv search --help","options":[{"names":["-i","--ignore-case"],"argument":"","description":"Case insensitive search. This is equivalent to prefixing the regex with '(?i)'."},{"names":["-s","--select"],"argument":"<arg>","description":"Select the columns to search. See 'xsv select -h' for the full syntax."},{"names":["-v","--invert-match"],"argument":"","description":"Select only rows that did not match"},{"names":["-h","--help"],"argument":"","description":"Display this message"},{"names":["-o","--output"],"argument":"<file>","description":"Write output to <file> instead of stdout."},{"names":["-n","--no-headers"],"argument":"","description":"When set, the first row will not be interpreted as headers. (i.e., They are not searched, analyzed, sliced, etc.)"},{"names":["-d","--delimiter"],"argument":"<arg>","description":"The field delimiter for reading CSV data. Must be a single character. (default: ,)"}]},{"name":"select","description":"Select columns from CSV","usage":"xsv select [options] [--] <selection> [<input>]\nxsv select --help","options":[{"names":["-h","--help"],"argument":"","description":"Display this message"},{"names":["-o","--output"],"argument":"<file>","description":"Write output to <file> instead of stdout."},{"names":["-n","--no-headers"],"argument":"","description":"When set, the first row will not be interpreted as headers. (i.e., They are not searched, analyzed, sliced, etc.)"},{"names":["-d","--delimiter"],"argument":"<arg>","description":"The field delimiter for reading CSV data. Must be a single character. (default: ,)"}]},{"name":"slice","description":"Slice records from CSV","usage":"xsv slice [options] [<input>]","options":[{"names":["-s","--start"],"argument":"<arg>","description":"The index of the record to slice from."},{"names":["-e","--end"],"argument":"<arg>","description":"The index of the record to slice to."},{"names":["-l","--len"],"argument":"<arg>","description":"The length of the slice (can be used instead of --end)."},{"names":["-i","--index"],"argument":"<arg>","description":"Slice a single record (shortcut for -s N -l 1)."},{"names":["-h","--help"],"argument":"","description":"Display this message"},{"names":["-o","--output"],"argument":"<file>","description":"Write output to <file> instead of stdout."},{"names":["-n","--no-headers"],"argument":"","description":"When set, the first row will not be interpreted as headers. Otherwise, the first row will always appear in the output as the header row."},{"names":["-d","--delimiter"],"argument":"<arg>","description":"The field delimiter for reading CSV data. Must be a single character. (default: ,)"}]},{"name":"sort","description":"Sort CSV data","usage":"xsv sort [options] [<input>]","options":[{"names":["-s","--select"],"argument":"<arg>","description":"Select a subset of columns to sort. See 'xsv select --help' for the format details."},{"names":["-N","--numeric"],"argument":"","description":"Compare according to string numerical value"},{"names":["-R","--reverse"],"argument":"","description":"Reverse order"},{"names":["-h","--help"],"argument":"","description":"Display this message"},{"names":["-o","--output"],"argument":"<file>","description":"Write output to <file> instead of stdout."},{"names":["-n","--no-headers"],"argument":"","description":"When set, the first row will not be interpreted as headers. Namely, it will be sorted with the rest of the rows. Otherwise, the first row will always appear as the header row in the output."},{"names":["-d","--delimiter"],"argument":"<arg>","description":"The field delimiter for reading CSV data. Must be a single character. (default: ,)"}]},{"name":"split","description":"Split CSV data into many files","usage":"xsv split [options] <outdir> [<input>]\nxsv split --help","options":[{"names":["-s","--size"],"argument":"<arg>","description":"The number of records to write into each chunk. [default: 500]"},{"names":["-j","--jobs"],"argument":"<arg>","description":"The number of spliting jobs to run in parallel. This only works when the given CSV data has an index already created. Note that a file handle is opened for each job. When set to '0', the number of jobs is set to the number of CPUs detected. [default: 0]"},{"names":["--filename"],"argument":"<filename>","description":"A filename template to use when constructing the names of the output files. The string '{}' will be replaced by a value based on the value of the field, but sanitized for shell safety. [default: {}.csv]"},{"names":["-h","--help"],"argument":"","description":"Display this message"},{"names":["-n","--no-headers"],"argument":"","description":"When set, the first row will NOT be interpreted as column names. Otherwise, the first row will appear in all chunks as the header row."},{"names":["-d","--delimiter"],"argument":"<arg>","description":"The field delimiter for reading CSV data. Must be a single character. (default: ,)"}]},{"name":"stats","description":"Compute basic statistics","usage":"xsv stats [options] [<input>]","options":[{"names":["-s","--select"],"argument":"<arg>","description":"Select a subset of columns to compute stats for. See 'xsv select --help' for the format details. This is provided here because piping 'xsv select' into 'xsv stats' will disable the use of indexing."},{"names":["--everything"],"argument":"","description":"Show all statistics available."},{"names":["--mode"],"argument":"Show the mode.","description":"This requires storing all CSV data in memory."},{"names":["--cardinality"],"argument":"Show the cardinality.","description":"This requires storing all CSV data in memory."},{"names":["--median"],"argument":"Show the median.","description":"This requires storing all CSV data in memory."},{"names":["--nulls"],"argument":"","description":"Include NULLs in the population size for computing mean and standard deviation."},{"names":["-j","--jobs"],"argument":"<arg>","description":"The number of jobs to run in parallel. This works better when the given CSV data has an index already created. Note that a file handle is opened for each job. When set to '0', the number of jobs is set to the number of CPUs detected. [default: 0]"},{"names":["-h","--help"],"argument":"","description":"Display this message"},{"names":["-o","--output"],"argument":"<file>","description":"Write output to <file> instead of stdout."},{"names":["-n","--no-headers"],"argument":"","description":"When set, the first row will NOT be interpreted as column names. i.e., They will be included in statistics."},{"names":["-d","--delimiter"],"argument":"<arg>","description":"The field delimiter for reading CSV data. Must be a single character. (default: ,)"}]},{"name":"table","description":"Align CSV data into columns","usage":"xsv table [options] [<input>]","options":[{"names":["-w","--width"],"argument":"<arg>","description":"The minimum width of each column. [default: 2]"},{"names":["-p","--pad"],"argument":"<arg>","description":"The minimum number of spaces between each column. [default: 2]"},{"names":["-c","--condense"],"argument":"<arg>","description":"Limits the length of each field to the value   specified. If the field is UTF-8 encoded, then <arg> refers to the number of code points. Otherwise, it refers to the number of bytes."},{"names":["-h","--help"],"argument":"","description":"Display this message"},{"names":["-o","--output"],"argument":"<file>","description":"Write output to <file> instead of stdout."},{"names":["-d","--delimiter"],"argument":"<arg>","description":"The field delimiter for reading CSV data. Must be a single character. (default: ,)"}]}],"version":"0.13.0","tldr":"> A CSV command-line toolkit written in Rust.\n> More information: <https://github.com/BurntSushi/xsv>.\n\n- Inspect the headers of a file:\n\n`xsv headers {{path/to/file.csv}}`\n\n- Count the number of entries:\n\n`xsv count {{path/to/file.csv}}`\n\n- Get an overview of the shape of entries:\n\n`xsv stats {{path/to/file.csv}} | xsv table`\n\n- Select a few columns:\n\n`xsv select {{column_a,column_b}} {{path/to/file.csv}}`\n\n- Show 10 random entries:\n\n`xsv sample {{10}} {{path/to/file.csv}}`\n\n- Join a column from one file to another:\n\n`xsv join --no-case {{column_a}} {{path/to/file/a.csv}} {{column_b}} {{path/to/file/b.csv}} | xsv table`\n"}
