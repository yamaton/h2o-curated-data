#compdef _pv pv

# Auto-generated with h2o


function _pv {
    local line state

    function _commands {
        local -a commands
        commands=(
        )
        _describe 'command' commands
    }
 

    _arguments -C \
        {-p,--progress}'[Turn the progress bar on. If standard input is not a file and no size was given (with the -s modifier), the progress bar cannot indicate how close to completion the transfer is, so it will just move left and right to indicate that data is moving.]' \
        {-t,--timer}'[Turn the timer on. This will display the total elapsed time that pv has been running for.]' \
        {-e,--eta}'[Turn the ETA timer on. This will attempt to guess, based on previous transfer rates and the total data size, how long it will be before completion. This option will have no effect if the total data size cannot be determined.]' \
        {-I,--fineta}'[Turn the ETA timer on, but display the estimated local time of arrival instead of time left. When the estimated time is more than 6 hours in the future, the date is shown as well.]' \
        {-r,--rate}'[Turn the rate counter on. This will display the current rate of data transfer.]' \
        {-a,--average-rate}'[Turn the average rate counter on. This will display the average rate of data transfer so far.]' \
        {-b,--bytes}'[Turn the total byte counter on. This will display the total amount of data transferred so far.]' \
        {-T,--buffer-percent}'[Turn on the transfer buffer percentage display. This will show the percentage of the transfer buffer in use - but see the caveat under %T in the FORMATTING section below.]' \
        {-A,--last-written}'[Show the last NUM bytes written - but see the caveat under %nA in the FORMATTING section below.]' \
        {-F,--format}'[Ignore the options -p, -t, -e, -r, -a, -b, -T, and -A, and instead use the format string FORMAT to determine the output format. See the FORMATTING section below.]' \
        {-n,--numeric}'[Numeric output. Instead of giving a visual indication of progress, pv will give an integer percentage, one per line, on standard error, suitable for piping (via convoluted redirection) into dialog(1). Note that -f is not required if -n is being used.]' \
        {-q,--quiet}'[No output. Useful if the -L option is being used on its own to just limit the transfer rate of a pipe.]' \
        {-W,--wait}'[Wait until the first byte has been transferred before showing any progress information or calculating any ETAs. Useful if the program you are piping to or from requires extra information before it starts, eg piping data into gpg(1) or mcrypt(1) which require a passphrase before data can be processed.]' \
        {-D,--delay-start}'[Wait until SEC seconds have passed before showing any progress information, for example in a script where you only want to show a progress bar if it starts taking a long time. Note that this can be a decimal such as 0.5.]' \
        {-s,--size}'[Assume the total amount of data to be transferred is SIZE bytes when calculating percentages and ETAs. The same suffixes of "k", "m" etc can be used as with -L.]' \
        {-l,--line-mode}'[Instead of counting bytes, count lines (newline characters). The progress bar will only move when a new line is found, and the value passed to the -s option will be interpreted as a line count. Note that file sizes are not automatically calculated when this option is used, to avoid having to read all files twice.]' \
        {-0,--null}'[Count lines as null terminated. This option implies --line-mode.]' \
        {-i,--interval}'[Wait SEC seconds between updates. The default is to update every second. Note that this can be a decimal such as 0.1.]' \
        {-w,--width}'[Assume the terminal is WIDTH characters wide, instead of trying to work it out (or assuming 80 if it cannot be guessed).]' \
        {-H,--height}'[Assume the terminal is HEIGHT rows high, instead of trying to work it out (or assuming 25 if it cannot be guessed).]' \
        {-N,--name}'[Prefix the output information with NAME. Useful in conjunction with -c if you have a complicated pipeline and you want to be able to tell different parts of it apart.]' \
        {-f,--force}'[Force output. Normally, pv will not output any visual display if standard error is not a terminal. This option forces it to do so.]' \
        {-c,--cursor}'[Use cursor positioning escape sequences instead of just using carriage returns. This is useful in conjunction with -N (name) if you are using multiple pv invocations in a single, long, pipeline.]' \
        {-L,--rate-limit}'[Limit the transfer to a maximum of RATE bytes per second. A suffix of "K", "M", "G", or "T" can be added to denote kibibytes (*1024), mebibytes, and so on.]' \
        {-B,--buffer-size}'[Use a transfer buffer size of BYTES bytes. A suffix of "K", "M", "G", or "T" can be added to denote kibibytes (*1024), mebibytes, and so on. The default buffer size is the block size of the input file'\''s filesystem multiplied by 32 (512KiB max), or 400KiB if the block size cannot be determined.]' \
        {-C,--no-splice}'[Never use splice(2), even if it would normally be possible. The splice(2) system call is a more efficient way of transferring data from or to a pipe than regular read(2) and write(2), but means that the transfer buffer may not be used. This prevents -A and -T from working, so if you want to use -A or -T then you will need to use -C, at the cost of a small loss in transfer efficiency. (This option has no effect on systems where splice(2) is unavailable).]' \
        {-E,--skip-errors}'[Ignore read errors by attempting to skip past the offending sections. The corresponding parts of the output will be null bytes. At first only a few bytes will be skipped, but if there are many errors in a row then the skips will move up to chunks of 512. This is intended to be similar to dd conv=sync,noerror but has not been as thoroughly tested.]' \
        {-S,--stop-at-size}'[If a size was specified with -s, stop transferring data once that many bytes have been written, instead of continuing to the end of input.]' \
        {-d,--watchfd}'[Instead of transferring data, watch file descriptor FD of process PID, and show its progress. The pv process will exit when FD either changes to a different file, changes read/write mode, or is closed; other data transfer modifiers - and remote control - may not be used with this option.]' \
        {-R,--remote}'[If PID is an instance of pv that is already running, -R PID will cause that instance to act as though it had been given this instance'\''s command line instead. For example, if pv -L 123K is running with process ID 9876, then running pv -R 9876 -L 321K will cause it to start using a rate limit of 321KiB instead of 123KiB. Note that some options cannot be changed while running, such as -c, -l, -f, -D, -E, and -S.]' \
        {-P,--pidfile}'[Save the process ID of pv in FILE. The file will be truncated if it already exists, and will be removed when pv exits. While pv is running, it will contain a single number - the process ID of pv - followed by a newline.]':file:_files \
        {-h,--help}'[Print a usage message on standard output and exit successfully.]' \
        {-V,--version}'[Print version information on standard output and exit successfully.]' \
        '*: :_files'

    case $state in
    (cmd)
        _commands
        ;;
    (subcmd)
        case $line[1] in
        esac
        ;;
     esac

}

