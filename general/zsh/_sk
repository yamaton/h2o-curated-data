#compdef _sk sk

# Auto-generated with h2o


function _sk {
    local line state

    function _commands {
        local -a commands
        commands=(
        )
        _describe 'command' commands
    }
 

    _arguments -C \
        {-h,--help}'[print this help menu]' \
        '--version[print out the current version of skim]' \
        '--tac[reverse the order of search result]' \
        '--no-sort[Do not sort the result]' \
        {-n,--nth}'[specify the fields to be matched]' \
        '--with-nth[specify the fields to be transformed]' \
        '--regex[use regex instead of fuzzy match]' \
        '--algo[Fuzzy matching algorithm: \[skim_v1|skim_v2|clangd\] (default: skim_v2)]' \
        '--case[case sensitive or not]' \
        {-b,--bind}'[comma seperated keybindings, in KEY:ACTION such as '\''ctrl-j:accept,ctrl-k:kill-line'\'']' \
        {-m,--multi}'[Enable Multiple Selection]' \
        '--no-multi[Disable Multiple Selection]' \
        '--no-mouse[Disable mouse events]' \
        {-c,--cmd}'[command to invoke dynamically]' \
        {-i,--interactive}'[Start skim in interactive(command) mode]' \
        '--color[change color theme]' \
        '--no-hscroll[Disable horizontal scroll]' \
        '--keep-right[Keep the right end of the line visible on overflow]' \
        '--skip-to-pattern[Line starts with the start of matched pattern]' \
        '--no-clear-if-empty[Do not clear previous items if command returns empty result]' \
        '--show-cmd-error[Send command error message if command fails]' \
        '--layout[Choose layout: \[default|reverse|reverse-list\]]' \
        '--height[Height of skim'\''s window (--height 40%)]' \
        '--no-height[Disable height feature]' \
        '--min-height[Minimum height when --height is given by percent (default: 10)]' \
        '--margin[Screen Margin (TRBL / TB,RL / T,RL,B / T,R,B,L) e.g. (sk --margin 1,10%)]' \
        {-p,--prompt}'[prompt string for query mode]' \
        '--cmd-prompt[prompt string for command mode]' \
        '--ansi[parse ANSI color codes for input strings]' \
        '--tabstop[Number of spaces for a tab character (default: 8)]' \
        '--inline-info[Display info next to query]' \
        '--header[Display STR next to info]' \
        '--header-lines[The first N lines of the input are treated as header]' \
        '--history[History file]':file:_files \
        '--history-size[Maximum number of query history entries (default: 1000)]' \
        '--cmd-history[command History file]':file:_files \
        '--cmd-history-size[Maximum number of command history entries (default: 1000)]' \
        '--preview[command to preview current highlighted line ({}) We can specify the fields. e.g. ({1}, {..3}, {0..})]' \
        {-q,--query}'[specify the initial query]' \
        '--cmd-query[specify the initial query for interactive mode]' \
        '--expect[comma seperated keys that can be used to complete skim]' \
        '--read0[Read input delimited by ASCII NUL(\0) characters]' \
        '--print0[Print output delimited by ASCII NUL(\0) characters]' \
        '--no-clear[Do not clear screen on exit]' \
        '--print-query[Print query as the first line]' \
        '--print-cmd[Print command query as the first line (after --print-query)]' \
        '--print-score[Print matching score in filter output (with --filter)]' \
        {-1,--select-1}'[Automatically select the only match]' \
        {-0,--exit-0}'[Exit immediately when there'\''s no match]' \
        '--sync[Synchronous search for multi-staged filtering]' \
        '--pre-select-n[Pre-select the first n items in multi-selection mode]' \
        '--pre-select-pat[Pre-select the matched items in multi-selection mode]' \
        '--pre-select-file[Pre-select the items read from file]':file:_files \
        '-I[replace `replstr` with the selected item]' \
        '--extended[--literal]' \
        '--cycle[--hscroll-off=COL]' \
        '--filepath-word[--jump-labels=CHARS]' \
        '--border[--no-bold]' \
        '--info[--pointer]' \
        '--marker[--phony]' \
        '*: :_files'

    case $state in
    (cmd)
        _commands
        ;;
    (subcmd)
        case $line[1] in
        esac
        ;;
     esac

}

